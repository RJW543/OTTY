"""
OTP Messaging Client for Raspberry Pi 5
Encrypts messages using one-time pad pages generated by the OTP Generator.
Works with credentials.txt from the username input and otp_cipher.txt from the generator.
"""

import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
import socket
import threading
import fcntl
from pathlib import Path
from datetime import datetime

# Optional: Text-to-speech for received messages
try:
    import pyttsx3
    TTS_AVAILABLE = True
except ImportError:
    TTS_AVAILABLE = False


# --- CONFIGURATION ---
OTP_FILE = "otp_cipher.txt"
USED_PAGES_FILE = "used_pages.txt"
USED_PAGES_LOCK = "used_pages.lock"
CREDENTIALS_FILE = "credentials.txt"
PAGE_ID_LENGTH = 8  # First 8 characters of each OTP page are the identifier


# --- OTP MANAGEMENT ---

def load_otp_pages(file_name=OTP_FILE):
    """
    Load OTP pages from file.
    Each line is treated as: first 8 chars = identifier, rest = OTP content.
    """
    otp_pages = []
    file_path = Path(file_name)
    
    if not file_path.exists():
        return otp_pages
    
    with file_path.open("r", encoding="utf-8") as f:
        for line_num, line in enumerate(f, 1):
            line = line.rstrip('\n')
            if len(line) < PAGE_ID_LENGTH + 1:
                continue
            
            identifier = line[:PAGE_ID_LENGTH]
            content = line[PAGE_ID_LENGTH:]
            otp_pages.append((identifier, content))
    
    return otp_pages


def load_used_pages(file_name=USED_PAGES_FILE):
    """Load the set of already-used OTP page identifiers."""
    file_path = Path(file_name)
    if not file_path.exists():
        return set()
    
    with file_path.open("r", encoding="utf-8") as f:
        return {line.strip() for line in f if line.strip()}


def mark_page_used(identifier, file_name=USED_PAGES_FILE, lock_file=USED_PAGES_LOCK):
    """Mark an OTP page as used with file locking for safety."""
    with open(lock_file, "w") as lock:
        fcntl.flock(lock, fcntl.LOCK_EX)
        try:
            with open(file_name, "a", encoding="utf-8") as f:
                f.write(f"{identifier}\n")
        finally:
            fcntl.flock(lock, fcntl.LOCK_UN)


def get_next_otp_page(otp_pages, used_identifiers, lock_file=USED_PAGES_LOCK):
    """
    Find and reserve the next unused OTP page.
    Uses file locking to prevent race conditions.
    Returns (identifier, content) or (None, None) if exhausted.
    """
    with open(lock_file, "w") as lock:
        fcntl.flock(lock, fcntl.LOCK_EX)
        try:
            # Reload used pages in case another process marked some
            current_used = load_used_pages()
            
            for identifier, content in otp_pages:
                if identifier not in current_used:
                    # Mark as used immediately
                    with open(USED_PAGES_FILE, "a", encoding="utf-8") as f:
                        f.write(f"{identifier}\n")
                    used_identifiers.add(identifier)
                    return identifier, content
        finally:
            fcntl.flock(lock, fcntl.LOCK_UN)
    
    return None, None


# --- ENCRYPTION ---

def xor_encrypt(plaintext, otp_content):
    """
    Encrypt plaintext using XOR with OTP content.
    Returns encrypted bytes as hex string for safe transmission.
    """
    encrypted_bytes = []
    for i, char in enumerate(plaintext):
        if i >= len(otp_content):
            break
        encrypted_byte = ord(char) ^ ord(otp_content[i])
        encrypted_bytes.append(encrypted_byte)
    
    # Convert to hex string for safe transmission
    return bytes(encrypted_bytes).hex()


def xor_decrypt(hex_encrypted, otp_content):
    """
    Decrypt hex-encoded encrypted message using XOR with OTP content.
    """
    try:
        encrypted_bytes = bytes.fromhex(hex_encrypted)
    except ValueError:
        return "[Decryption Error: Invalid hex data]"
    
    decrypted_chars = []
    for i, byte in enumerate(encrypted_bytes):
        if i >= len(otp_content):
            break
        decrypted_char = chr(byte ^ ord(otp_content[i]))
        decrypted_chars.append(decrypted_char)
    
    return ''.join(decrypted_chars)


# --- USERNAME LOADING ---

def load_username_from_credentials(file_name=CREDENTIALS_FILE):
    """
    Load the most recent username from credentials.txt.
    The file format from the username input is: "Username: <name>"
    """
    file_path = Path(file_name)
    if not file_path.exists():
        return None
    
    username = None
    with file_path.open("r", encoding="utf-8") as f:
        for line in f:
            if line.startswith("Username:"):
                username = line.replace("Username:", "").strip()
    
    return username


# --- CLIENT GUI ---

class OTPClientGUI:
    """Main GUI for the OTP Messaging Client."""
    
    def __init__(self, master):
        self.master = master
        self.master.title("OTP Secure Messenger")
        self.master.geometry("650x550")
        self.master.minsize(600, 500)
        
        # State
        self.client_socket = None
        self.user_id = None
        self.connected = False
        
        # Load OTP pages
        self.otp_pages = load_otp_pages()
        self.used_identifiers = load_used_pages()
        
        # TTS engine (optional)
        self.tts_engine = None
        if TTS_AVAILABLE:
            try:
                self.tts_engine = pyttsx3.init()
            except:
                pass
        
        self.setup_ui()
        self.check_prerequisites()
    
    def setup_ui(self):
        """Build the user interface."""
        style = ttk.Style()
        style.theme_use('clam')
        
        main_frame = ttk.Frame(self.master, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # --- Connection Section ---
        conn_frame = ttk.LabelFrame(main_frame, text="Connection", padding="10")
        conn_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Server address row
        server_row = ttk.Frame(conn_frame)
        server_row.pack(fill=tk.X, pady=(0, 5))
        
        ttk.Label(server_row, text="Server:").pack(side=tk.LEFT)
        self.host_entry = ttk.Entry(server_row, width=25)
        self.host_entry.insert(0, "0.tcp.ngrok.io")
        self.host_entry.pack(side=tk.LEFT, padx=(5, 10))
        
        ttk.Label(server_row, text="Port:").pack(side=tk.LEFT)
        self.port_entry = ttk.Entry(server_row, width=8)
        self.port_entry.insert(0, "12345")
        self.port_entry.pack(side=tk.LEFT, padx=(5, 0))
        
        # Username row
        user_row = ttk.Frame(conn_frame)
        user_row.pack(fill=tk.X, pady=(5, 0))
        
        ttk.Label(user_row, text="Username:").pack(side=tk.LEFT)
        self.username_entry = ttk.Entry(user_row, width=20)
        self.username_entry.pack(side=tk.LEFT, padx=(5, 10))
        
        # Load username from credentials if available
        saved_username = load_username_from_credentials()
        if saved_username:
            self.username_entry.insert(0, saved_username)
        
        self.connect_button = ttk.Button(user_row, text="Connect", command=self.connect_to_server)
        self.connect_button.pack(side=tk.LEFT, padx=(10, 0))
        
        self.disconnect_button = ttk.Button(
            user_row, text="Disconnect", command=self.disconnect, state=tk.DISABLED
        )
        self.disconnect_button.pack(side=tk.LEFT, padx=(5, 0))
        
        # Connection status
        self.status_label = ttk.Label(conn_frame, text="● Disconnected", foreground="red")
        self.status_label.pack(anchor=tk.W, pady=(5, 0))
        
        # --- OTP Status Section ---
        otp_frame = ttk.LabelFrame(main_frame, text="OTP Status", padding="5")
        otp_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.otp_status_label = ttk.Label(otp_frame, text="Loading...")
        self.otp_status_label.pack(anchor=tk.W)
        
        # --- Chat Section ---
        chat_frame = ttk.LabelFrame(main_frame, text="Messages", padding="5")
        chat_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        self.chat_area = scrolledtext.ScrolledText(
            chat_frame, height=12, state=tk.DISABLED, font=("Consolas", 10)
        )
        self.chat_area.pack(fill=tk.BOTH, expand=True)
        
        # Configure text tags for styling
        self.chat_area.tag_configure("sent", foreground="#0066cc")
        self.chat_area.tag_configure("received", foreground="#006600")
        self.chat_area.tag_configure("system", foreground="#666666", font=("Consolas", 9, "italic"))
        self.chat_area.tag_configure("error", foreground="#cc0000")
        
        # --- Message Input Section ---
        input_frame = ttk.LabelFrame(main_frame, text="Send Message", padding="10")
        input_frame.pack(fill=tk.X)
        
        # Recipient row
        recipient_row = ttk.Frame(input_frame)
        recipient_row.pack(fill=tk.X, pady=(0, 5))
        
        ttk.Label(recipient_row, text="To:").pack(side=tk.LEFT)
        self.recipient_entry = ttk.Entry(recipient_row, width=20)
        self.recipient_entry.pack(side=tk.LEFT, padx=(5, 0))
        
        # Message row
        message_row = ttk.Frame(input_frame)
        message_row.pack(fill=tk.X)
        
        ttk.Label(message_row, text="Message:").pack(side=tk.LEFT)
        self.message_entry = ttk.Entry(message_row, width=40)
        self.message_entry.pack(side=tk.LEFT, padx=(5, 10), fill=tk.X, expand=True)
        self.message_entry.bind("<Return>", lambda e: self.send_message())
        
        self.send_button = ttk.Button(message_row, text="Send", command=self.send_message, state=tk.DISABLED)
        self.send_button.pack(side=tk.LEFT)
    
    def check_prerequisites(self):
        """Check that OTP file exists and has unused pages."""
        total_pages = len(self.otp_pages)
        used_count = len(self.used_identifiers)
        available = total_pages - used_count
        
        if total_pages == 0:
            self.otp_status_label.config(
                text=f"⚠ No OTP file found! Run the OTP Generator first.",
                foreground="red"
            )
            self.add_chat_message(
                "No otp_cipher.txt found. Please run the OTP Generator to create one.",
                "error"
            )
        elif available == 0:
            self.otp_status_label.config(
                text=f"⚠ All {total_pages} OTP pages have been used!",
                foreground="red"
            )
        else:
            self.otp_status_label.config(
                text=f"✓ {available} pages available ({used_count} used of {total_pages} total)",
                foreground="green"
            )
    
    def add_chat_message(self, message, tag="system"):
        """Add a message to the chat area."""
        timestamp = datetime.now().strftime("%H:%M")
        
        self.chat_area.config(state=tk.NORMAL)
        self.chat_area.insert(tk.END, f"[{timestamp}] {message}\n", tag)
        self.chat_area.see(tk.END)
        self.chat_area.config(state=tk.DISABLED)
    
    def connect_to_server(self):
        """Establish connection to the relay server."""
        host = self.host_entry.get().strip()
        port_str = self.port_entry.get().strip()
        username = self.username_entry.get().strip()
        
        if not host or not port_str:
            messagebox.showwarning("Warning", "Please enter server host and port.")
            return
        
        if not username:
            messagebox.showwarning("Warning", "Please enter a username.")
            return
        
        try:
            port = int(port_str)
        except ValueError:
            messagebox.showwarning("Warning", "Port must be a number.")
            return
        
        self.add_chat_message(f"Connecting to {host}:{port}...", "system")
        
        try:
            self.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.client_socket.settimeout(10)
            self.client_socket.connect((host, port))
            self.client_socket.settimeout(None)
            
            # Send username
            self.client_socket.sendall(username.encode("utf-8"))
            
            # Wait for response
            response = self.client_socket.recv(1024).decode("utf-8")
            
            if response.startswith("ERROR"):
                error_msg = response.split("|", 1)[1] if "|" in response else response
                self.add_chat_message(f"Connection failed: {error_msg}", "error")
                self.client_socket.close()
                self.client_socket = None
                return
            
            # Connected successfully
            self.user_id = username
            self.connected = True
            
            # Update UI
            self.status_label.config(text=f"● Connected as '{username}'", foreground="green")
            self.connect_button.config(state=tk.DISABLED)
            self.disconnect_button.config(state=tk.NORMAL)
            self.send_button.config(state=tk.NORMAL)
            self.host_entry.config(state=tk.DISABLED)
            self.port_entry.config(state=tk.DISABLED)
            self.username_entry.config(state=tk.DISABLED)
            
            self.add_chat_message("Connected to server!", "system")
            
            # Start receive thread
            receive_thread = threading.Thread(target=self.receive_messages, daemon=True)
            receive_thread.start()
            
        except socket.timeout:
            self.add_chat_message("Connection timed out.", "error")
            messagebox.showerror("Error", "Connection timed out.")
        except ConnectionRefusedError:
            self.add_chat_message("Connection refused. Is the server running?", "error")
            messagebox.showerror("Error", "Connection refused. Is the server running?")
        except Exception as e:
            self.add_chat_message(f"Connection error: {e}", "error")
            messagebox.showerror("Error", f"Failed to connect: {e}")
    
    def disconnect(self):
        """Disconnect from the server."""
        self.connected = False
        
        if self.client_socket:
            try:
                self.client_socket.close()
            except:
                pass
            self.client_socket = None
        
        # Update UI
        self.status_label.config(text="● Disconnected", foreground="red")
        self.connect_button.config(state=tk.NORMAL)
        self.disconnect_button.config(state=tk.DISABLED)
        self.send_button.config(state=tk.DISABLED)
        self.host_entry.config(state=tk.NORMAL)
        self.port_entry.config(state=tk.NORMAL)
        self.username_entry.config(state=tk.NORMAL)
        
        self.add_chat_message("Disconnected from server.", "system")
    
    def send_message(self):
        """Encrypt and send a message."""
        if not self.connected:
            return
        
        recipient = self.recipient_entry.get().strip()
        message = self.message_entry.get().strip()
        
        if not recipient:
            messagebox.showwarning("Warning", "Please enter a recipient.")
            return
        
        if not message:
            messagebox.showwarning("Warning", "Please enter a message.")
            return
        
        if recipient == self.user_id:
            messagebox.showwarning("Warning", "You cannot message yourself.")
            return
        
        # Get next OTP page
        otp_id, otp_content = get_next_otp_page(self.otp_pages, self.used_identifiers)
        
        if not otp_id:
            messagebox.showerror("Error", "No OTP pages available! Generate more with the OTP Generator.")
            self.check_prerequisites()
            return
        
        # Check message length
        if len(message) > len(otp_content):
            messagebox.showwarning(
                "Warning", 
                f"Message too long! Max {len(otp_content)} characters with this OTP page."
            )
            return
        
        # Encrypt and send
        encrypted_hex = xor_encrypt(message, otp_content)
        
        # Format: recipient|otp_id:encrypted_hex
        full_message = f"{recipient}|{otp_id}:{encrypted_hex}"
        
        try:
            self.client_socket.sendall(full_message.encode("utf-8"))
            self.message_entry.delete(0, tk.END)
            self.add_chat_message(f"To {recipient}: {message}", "sent")
            self.check_prerequisites()  # Update OTP count
            
        except Exception as e:
            self.add_chat_message(f"Failed to send: {e}", "error")
    
    def receive_messages(self):
        """Background thread to receive messages."""
        while self.connected and self.client_socket:
            try:
                data = self.client_socket.recv(8192)
                if not data:
                    break
                
                message = data.decode("utf-8")
                self.process_received_message(message)
                
            except ConnectionResetError:
                break
            except Exception as e:
                if self.connected:
                    self.master.after(0, lambda: self.add_chat_message(f"Receive error: {e}", "error"))
                break
        
        # Connection lost
        if self.connected:
            self.master.after(0, self.handle_disconnect)
    
    def process_received_message(self, raw_message):
        """Parse and decrypt a received message."""
        try:
            # Format: sender_id|otp_id:encrypted_hex
            sender_id, payload = raw_message.split("|", 1)
            
            # Check for system messages
            if sender_id == "SYSTEM":
                if payload.startswith("offline:"):
                    offline_msg = payload.replace("offline:", "")
                    self.master.after(0, lambda: self.add_chat_message(offline_msg, "system"))
                return
            
            otp_id, encrypted_hex = payload.split(":", 1)
            
            # Find the OTP page
            otp_content = None
            for identifier, content in self.otp_pages:
                if identifier == otp_id:
                    otp_content = content
                    break
            
            if otp_content:
                # Decrypt the message
                decrypted = xor_decrypt(encrypted_hex, otp_content)
                
                # Mark this OTP page as used
                mark_page_used(otp_id)
                self.used_identifiers.add(otp_id)
                
                # Display
                self.master.after(0, lambda s=sender_id, m=decrypted: self.display_received(s, m))
            else:
                # Unknown OTP - display encrypted
                self.master.after(
                    0, 
                    lambda: self.add_chat_message(
                        f"From {sender_id}: [Unknown OTP {otp_id}] {encrypted_hex[:50]}...", 
                        "error"
                    )
                )
                
        except ValueError:
            self.master.after(0, lambda: self.add_chat_message(f"Malformed message received", "error"))
    
    def display_received(self, sender, message):
        """Display a received message and optionally speak it."""
        self.add_chat_message(f"From {sender}: {message}", "received")
        self.check_prerequisites()
        
        # Text-to-speech (optional)
        if self.tts_engine:
            threading.Thread(target=self.speak_message, args=(message,), daemon=True).start()
    
    def speak_message(self, text):
        """Speak a message using TTS."""
        if self.tts_engine:
            try:
                self.tts_engine.say(text)
                self.tts_engine.runAndWait()
            except:
                pass
    
    def handle_disconnect(self):
        """Handle unexpected disconnection."""
        self.connected = False
        self.client_socket = None
        
        self.status_label.config(text="● Disconnected", foreground="red")
        self.connect_button.config(state=tk.NORMAL)
        self.disconnect_button.config(state=tk.DISABLED)
        self.send_button.config(state=tk.DISABLED)
        self.host_entry.config(state=tk.NORMAL)
        self.port_entry.config(state=tk.NORMAL)
        self.username_entry.config(state=tk.NORMAL)
        
        self.add_chat_message("Lost connection to server.", "error")
        messagebox.showwarning("Disconnected", "Lost connection to the server.")


def show_disclaimer():
    """Show legal disclaimer on startup."""
    disclaimer = (
        "DISCLAIMER\n\n"
        "This software is intended for educational and lawful use only.\n\n"
        "Users are responsible for complying with all applicable laws "
        "and regulations in their jurisdiction.\n\n"
        "The one-time pad provides information-theoretic security only when:\n"
        "• Each key page is truly random\n"
        "• Each key page is used only once\n"
        "• The key is kept secret"
    )
    messagebox.showinfo("OTP Secure Messenger", disclaimer)


def main():
    root = tk.Tk()
    show_disclaimer()
    app = OTPClientGUI(root)
    
    def on_close():
        if app.connected:
            app.disconnect()
        root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_close)
    root.mainloop()


if __name__ == "__main__":
    main()
